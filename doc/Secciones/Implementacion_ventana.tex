\chapter{Implementación del módulo Ventana}

\section{Introducción}

El módulo \textbf{Ventana} constituye el punto de entrada visual y de
interacción para el sistema. Este componente es responsable de la
creación, gestión y destrucción de la ventana principal de la aplicación, así
como del manejo de eventos de usuario y del ciclo de vida asociado a la
interfaz gráfica.

\section{Diseño y estructura de la clase Window}

La clase \texttt{Window}, ubicada en \texttt{src/ui/Window.h} y
\texttt{src/ui/Window.cpp}, encapsula toda la funcionalidad relacionada con la
ventana.

\subsection{Atributos principales}

\begin{itemize}
    \item \texttt{GLFWwindow* window}: Puntero al objeto de ventana gestionado por GLFW.
    \item \texttt{uint32\_t windowWidth, windowHeight}: Dimensiones internas de la ventana, actualizadas dinámicamente.
\end{itemize}

\subsection{Métodos públicos}

\begin{itemize}
    \item \texttt{bool Initialize(Renderer *renderer)}: Inicializa la ventana, configurando parámetros gráficos y de interacción, y registra los callbacks de eventos. La ventana se crea con una relación de aspecto fija (16:9), facilitando la integración con el pipeline gráfico y evitando distorsiones.
    \item \texttt{GLFWwindow* getWindow()}: Permite acceder al objeto de ventana desde otros módulos, especialmente el \texttt{Renderer} y la interfaz gráfica.
    \item \texttt{uint32\_t getWindowWidth()}, \texttt{getWindowHeight()}: Proporcionan las dimensiones actuales, utilizadas en la configuración de la proyección y el cálculo del aspecto.
    \item \texttt{void setWindowSize(uint32\_t width, uint32\_t height)}: Permite modificar las dimensiones internas de la ventana, útil en escenarios de redimensionado.
    \item \texttt{void Destroy()}: Libera los recursos asociados a la ventana, llamando a \texttt{glfwDestroyWindow}.
    \item \texttt{void SetWindowUserPointer(void* pointer)}: Permite asociar un puntero de usuario (normalmente, el \texttt{Renderer}) para su acceso desde los callbacks de eventos.
\end{itemize}

\subsection{Callbacks de eventos}

La clase Window define y registra varios callbacks estáticos:

\begin{itemize}
    \item \texttt{FramebufferSizeCallback(GLFWwindow* window, int width, int height)}: Se ejecuta cuando la ventana es redimensionada. Utiliza el puntero de usuario para acceder al \texttt{Renderer} y llama a su método \texttt{OnResize()}, lo que desencadena la reconfiguración de los buffers gráficos y la superficie de renderizado. Esto garantiza que el aspecto visual de la escena se mantenga correcto ante cualquier cambio de tamaño.
    \item \texttt{MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)}: Captura los eventos de pulsación de botones de ratón. Si la interfaz gráfica (ImGui) no está capturando el ratón, el evento se propaga al método \texttt{OnMouseButton} del \texttt{Renderer}, permitiendo la interacción directa con los objetos 3D a partir de los gizmos.
\end{itemize}

El registro de los callbacks se realiza en el método \texttt{Initialize},
asegurando que todos los eventos relevantes sean gestionados desde el inicio de
la aplicación.

\section{Proceso de inicialización y configuración}

El proceso de inicialización de la ventana sigue una secuencia de pasos bien
definida:

\begin{enumerate}
    \item Llamada a \texttt{glfwInit()} para inicializar la biblioteca GLFW.
    \item Configuración de los hints de ventana (\texttt{GLFW\_CLIENT\_API},
          \texttt{GLFW\_RESIZABLE}) para deshabilitar la API gráfica por defecto y
          permitir el redimensionado.
    \item Obtención del monitor y modo de vídeo principal para adaptar la ventana al
          entorno gráfico del usuario.
    \item Creación de la ventana con \texttt{glfwCreateWindow}, ajustando el tamaño al
          modo de vídeo y estableciendo el título (\texttt{"Copper"}).
    \item Fijación de la relación de aspecto mediante \texttt{glfwSetWindowAspectRatio},
          asegurando que la escena 3D se muestre correctamente.
    \item Registro de los callbacks de eventos (\texttt{FramebufferSizeCallback},
          \texttt{MouseButtonCallback}).
    \item Configuración de los modos de entrada (\texttt{GLFW\_CURSOR},
          \texttt{GLFW\_RAW\_MOUSE\_MOTION}) para gestionar el cursor y la interacción
          avanzada.
\end{enumerate}

Este diseño asegura que la ventana esté lista para recibir eventos y para
integrarse con el sistema de renderizado desde el primer momento.

\section{Gestión avanzada de eventos}

El manejo de eventos en la ventana es fundamental para la interactividad del
sistema. El diseño implementado permite:

\begin{itemize}
    \item \textbf{Sincronización con el pipeline gráfico}: Los eventos de redimensionado se propagan automáticamente al \texttt{Renderer}, que actualiza buffers, superficie y matrices de proyección, manteniendo la coherencia visual.
    \item \textbf{Integración con ImGui}: Antes de procesar eventos de ratón, se comprueba si ImGui está capturando el ratón, evitando conflictos entre la interfaz gráfica y la manipulación 3D.
\end{itemize}

El siguiente fragmento de código muestra la gestión y propagación de eventos
(\texttt{Window.cpp}):

\begin{verbatim}
void Window::MouseButtonCallback(GLFWwindow *window, int button, int action, int mods) {
    auto* renderer = static_cast<Renderer*>(glfwGetWindowUserPointer(window));
    if (renderer != nullptr && !ImGui::GetIO().WantCaptureMouse) {
        renderer->OnMouseButton(button, action);
    }
}
\end{verbatim}

\section{Interacción con otros componentes}

El módulo Ventana está estrechamente integrado con:

\begin{itemize}
    \item \texttt{Renderer}: Recibe y procesa los eventos relevantes para actualizar el pipeline gráfico y la escena.
    \item \texttt{Interfaz gráfica (GUI)}: Sirve como base para la integración de ImGui, permitiendo la edición y visualización de parámetros y objetos.
    \item \texttt{Subsistema de cámara y controles}: Los eventos de entrada capturados por la ventana se transmiten al controlador de cámara y gizmos, facilitando la manipulación interactiva de la escena.
\end{itemize}

La arquitectura facilita la extensión futura del sistema, permitiendo añadir
nuevas funcionalidades (por ejemplo, soporte para pantallas múltiples o
diferentes sistemas de entrada) sin modificar la lógica principal.
