\chapter{Arquitectura del sistema y compilación}

La arquitectura de \textbf{Copper} sigue principios de modularidad,
mantenibilidad y claridad estructural. A continuación se detallan los
diferentes módulos que componen el sistema, describiendo su funcionalidad y las
interacciones que mantienen entre sí.

\section{Módulo Core}

El módulo \textbf{Core} (\texttt{src/core/Core.cpp}, \texttt{src/core/Core.h})
es el responsable de gestionar el ciclo de vida de la aplicación. Sus funciones
principales incluyen:
\begin{itemize}
    \item \textbf{Inicialización}: Llama a los métodos de inicialización de los módulos \texttt{Window} y \texttt{Renderer} para preparar el entorno gráfico y la ventana principal.
    \item \textbf{Bucle principal}: Ejecuta el método \texttt{MainLoop()}, que gestiona los eventos y delega el renderizado de la escena.
    \item \textbf{Gestión de estado}: Permite saber si la aplicación sigue ejecutándose (\texttt{IsRunning()}) y controla el cierre ordenado de recursos (\texttt{Terminate()}).
\end{itemize}

\section{Módulo Window}

El módulo \textbf{Window} (\texttt{src/ui/Window.cpp},
\texttt{src/ui/Window.h}) se encarga de la creación y gestión de la ventana
principal de la aplicación, utilizando GLFW. Sus funciones incluyen:
\begin{itemize}
    \item \textbf{Configuración de la ventana}: Establece parámetros como el tamaño, aspecto y modo de interacción.
    \item \textbf{Gestión de eventos}: Implementa callbacks para eventos de redimensionado y de ratón, que se propagan al módulo \texttt{Renderer}.
    \item \textbf{Interfaz con el sistema}: Abstrae la interacción con el sistema operativo y facilita la obtención de dimensiones y el manejo del ciclo de vida de la ventana.
\end{itemize}
Esto permite que la ventana sea independiente del motor de renderizado y fácil de modificar o ampliar.

\section{Módulo Renderer}

El \textbf{Renderer} (\texttt{src/core/Renderer.cpp},
\texttt{src/core/Renderer.h}) es el motor gráfico del sistema. Sus principales
responsabilidades son:
\begin{itemize}
    \item \textbf{Inicialización de gráficos}: Configura el contexto de WebGPU, las superficies y los buffers necesarios para el renderizado.
    \item \textbf{Ciclo de renderizado}: Gestiona el bucle de renderizado, actualizando los datos de la escena y llamando a la función \texttt{Render()} en cada frame.
    \item \textbf{Gestión de uniforms}: Actualiza los uniforms (matriz MVP, posición de luz, tamaño de ventana, etc.) y los envía al shader.
    \item \textbf{Coordinación de módulos}: Instancia y gestiona los módulos \texttt{Camera}, \texttt{CameraController}, \texttt{GizmoControls}, \texttt{Coder} e \texttt{Interfaz (GUI)}, asegurando la comunicación entre ellos.
    \item \textbf{Gestión de interacción}: Recoge eventos de usuario (ratón, teclado) y los distribuye entre los controles de cámara, gizmo y selección de objetos.
\end{itemize}
Además, el renderer es responsable de actualizar el pipeline gráfico, por ejemplo, al modificar objetos SDF o parámetros visuales.

\section{Subsistema de Cámara}

\textbf{Camera} y \textbf{CameraController} (\texttt{src/core/Camera.cpp}, \texttt{src/core/Camera.h}, \texttt{src/core/CameraController.cpp}, \texttt{src/core/CameraController.h}) forman el subsistema encargado de gestionar la vista de la escena 3D.
\begin{itemize}
    \item \textbf{Camera}: Mantiene el estado (posición, centro, orientación) y permite obtener la matriz de vista y los vectores de orientación.
    \item \textbf{CameraController}: Implementa la lógica de interacción con el usuario (rotaciones, traslaciones, zoom) mediante eventos de ratón y teclado, actualizando la posición y orientación de la cámara en tiempo real.
    \item \textbf{Integración}: La cámara es utilizada tanto por el \texttt{Renderer} como por las herramientas de manipulación de objetos (\texttt{GizmoControls}).
\end{itemize}

\section{Módulo Coder}

El módulo \textbf{Coder} (\texttt{src/core/Coder.cpp},
\texttt{src/core/Coder.h}) se especializa en la generación dinámica de código
shader para el renderizado de objetos SDF. Sus funciones incluyen:
\begin{itemize}
    \item \textbf{Gestión de objetos}: Permite añadir, modificar y eliminar objetos SDF (esferas, cajas, conos, cilindros) y operaciones entre ellos (unión, intersección, sustracción).
    \item \textbf{Generación de shaders}: Construye el código shader que será utilizado en WebGPU para renderizar la escena y para operaciones de picking.
    \item \textbf{Selección y edición}: Gestiona el objeto actualmente seleccionado y expone métodos para editar sus propiedades y operación.
    \item \textbf{Almacenamiento de escenas}: Permite guardar y cargar escenas desde fichero, facilitando la persistencia y el intercambio de datos.
\end{itemize}

\section{Módulo GizmoControls}

El módulo \textbf{GizmoControls} (\texttt{src/core/GizmoControls.cpp},
\texttt{src/core/GizmoControls.h}) proporciona herramientas para la
manipulación visual e interactiva de los objetos SDF en la escena. Sus
responsabilidades son:
\begin{itemize}
    \item \textbf{Picking y manipulación}: Permite seleccionar e interactuar con los objetos mediante gizmos (ejes, planos de traslación).
    \item \textbf{Sincronización}: Mantiene la coherencia entre la posición del objeto, la cámara y el estado de la interacción.
    \item \textbf{Integración con el renderizado}: Utiliza la cámara y los datos de la escena para calcular las transformaciones y la interacción del usuario.
\end{itemize}

\section{Interfaz gráfica (GUI)}

El módulo \textbf{Interfaz} (\texttt{src/ui/Interfaz.cpp},
\texttt{src/ui/Interfaz.h}) implementa la interfaz gráfica de usuario
utilizando ImGui. Sus funciones principales son:
\begin{itemize}
    \item \textbf{Edición de objetos}: Permite modificar las propiedades de los objetos seleccionados (posición, tamaño, color, tipo, operación).
    \item \textbf{Gestión de la escena}: Ofrece controles para añadir, eliminar y editar objetos, así como para guardar y cargar escenas.
    \item \textbf{Control de parámetros globales}: Permite ajustar parámetros de iluminación, visualización y opciones de renderizado.
    \item \textbf{Comunicación}: Interactúa con los módulos \texttt{Coder} y \texttt{Renderer} para aplicar los cambios en tiempo real.
\end{itemize}

\section{Flujo de datos e interacción}

El flujo de datos e interacción entre módulos se organiza de la siguiente
manera:
\begin{itemize}
    \item \texttt{Core} inicializa \texttt{Window} y \texttt{Renderer}.
    \item \texttt{Renderer} instancia y coordina \texttt{Camera}, \texttt{CameraController}, \texttt{GizmoControls} y \texttt{Coder}.
    \item \texttt{CameraController} y \texttt{GizmoControls} gestionan la interacción directa del usuario.
    \item \texttt{Interfaz} permite la edición mediante ImGui y comunica los cambios a \texttt{Coder} y \texttt{Renderer}.
    \item \texttt{Coder} actualiza el shader y los objetos SDF, transmitiendo la información al renderer para el ciclo de renderizado.
\end{itemize}

\section{Diagrama de arquitectura}

\begin{figure}[H]
    \centering
    \resizebox{0.95\linewidth}{!}{%
        \begin{tikzpicture}[
            module/.style={rectangle, rounded corners, draw=black, thick, minimum width=2.8cm, minimum height=1cm, align=center, fill=gray!10},
            arrow/.style={-{Latex[length=3mm]}, thick},
            node distance=1.5cm and 2cm
            ]

            % Nodos principales (jerarquía vertical)
            \node[module] (core) {Core};

            \node[module, below left=of core] (window) {Window};
            \node[module, below right=of core] (renderer) {Renderer};

            % Renderer dependencias
            \node[module, below=of renderer] (camera) {Camera};
            \node[module, right=of camera] (cameracontroller) {CameraController};
            \node[module, right=of renderer] (gizmo) {GizmoControls};
            \node[module, left=of camera] (coder) {Coder};

            % Interfaz a la izquierda
            \node[module, left=of coder] (interfaz) {Interfaz};

            % Flechas Core
            \draw[arrow] (core) -- (window);
            \draw[arrow] (core) -- (renderer);

            % Flechas Renderer
            \draw[arrow] (renderer) -- (camera);
            \draw[arrow] (renderer) -- (cameracontroller);
            \draw[arrow] (renderer) -- (gizmo);
            \draw[arrow] (renderer) -- (coder);

            % Interacción de usuario
            \draw[arrow] (cameracontroller) -- (renderer);
            \draw[arrow] (gizmo) -- (renderer);

            % Interfaz comunica
            \draw[arrow] (interfaz) -- (coder);
            \draw[arrow] (interfaz) -- (renderer);

            % Coder actualiza
            \draw[arrow] (coder) -- (renderer);

        \end{tikzpicture}
    }
    \caption{Arquitectura de Copper: relación entre módulos principales.}
    \label{fig:arquitectura-copper}
\end{figure}

\section{Justificación de la arquitectura}

La estructura modular y jerárquica implementada en Copper permite separar
responsabilidades, facilitar el mantenimiento y la escalabilidad del sistema.
Las decisiones de diseño han sido tomadas para maximizar la claridad, la
reutilización y la posibilidad de extensión futura del sistema de acuerdo a los
siguientes criterios:

\begin{itemize}
    \item \textbf{Separación de responsabilidades}: El diseño modular permite que cada componente (núcleo, renderizado, cámara, gestión de objetos, manipulación, interfaz) se encargue de una función específica, lo que facilita la comprensión, el mantenimiento y la evolución del sistema. Por ejemplo, \texttt{Core} sólo gestiona el ciclo de vida y delega el renderizado a \texttt{Renderer}, mientras que la creación y edición de objetos SDF queda aislada en \texttt{Coder}.
    \item \textbf{Facilidad de extensión}: La existencia de clases independientes para cada tipo de objeto (\texttt{sphere}, \texttt{box}, \texttt{cone}, \texttt{cylinder}) y para operaciones (\texttt{union}, \texttt{subtract}, \texttt{intersection}, etc.) en \texttt{Coder} permite añadir nuevos tipos u operaciones sin modificar el núcleo del sistema, como se observa en los métodos \texttt{addSphere}, \texttt{addBox}, etc. [\texttt{src/core/Coder.cpp}, \texttt{src/core/Coder.h}].
    \item \textbf{Interactividad y desacoplamiento}: Los subsistemas de cámara y control de objetos (Camera/CameraController, GizmoControls) están desacoplados de la lógica de renderizado, permitiendo que la interacción del usuario se procese de forma independiente y se integre fácilmente con la interfaz gráfica (\texttt{Interfaz.cpp}).
    \item \textbf{Actualización eficiente del renderizado}: El sistema de notificación de cambios (\texttt{pipelineDirty} en \texttt{Renderer}, activado por modificaciones en \texttt{Coder} o en la escena) permite que el pipeline gráfico se actualice sólo cuando es necesario, optimizando el rendimiento y evitando cálculos redundantes (\texttt{src/core/Renderer.cpp}).
\end{itemize}

\section{Sistema de construcción y compilación del proyecto: CMake}

El proyecto utiliza \textbf{CMake} como sistema de construcción para gestionar
la compilación, las dependencias y la organización de los archivos fuente.
CMake es una herramienta ampliamente empleada en proyectos de desarrollo de
software en C y C++ por su capacidad para generar archivos de construcción para
distintos sistemas y entornos \cite{cmake-docs}.

\subsection{Estructura del archivo CMake}

En la raíz del proyecto se encuentra el archivo \texttt{CMakeLists.txt}, que
define la configuración de la construcción. Sus principales componentes y
funcionalidades son:

\begin{itemize}
    \item \textbf{Definición del proyecto:}\\
          El proyecto se denomina \texttt{Copper}, está configurado para compilar en C++20 y se identifica como una aplicación de modelado 3D basada en SDF:
          \begin{lstlisting}[language=CMake, caption={Definición del proyecto en CMakeLists.txt}]
            project(Copper VERSION 0.0.2 LANGUAGES CXX C DESCRIPTION "3D SDF-based modeling application")
            set(CMAKE_CXX_STANDARD 20)
            set(CMAKE_CXX_STANDARD_REQUIRED ON)
            set(CMAKE_CXX_EXTENSIONS OFF)
\end{lstlisting}

    \item \textbf{Gestión de dependencias externas:}\\
          El archivo especifica la inclusión y compilación de bibliotecas externas necesarias para el funcionamiento del proyecto, como Dawn (WebGPU), GLM (matemáticas), ImGuiFileDialog (diálogos de archivos en la interfaz gráfica), y las fuentes de ImGui. La gestión de dependencias se realiza mediante \texttt{add\_subdirectory} y \texttt{FetchContent}, permitiendo su descarga y compilación automática junto al proyecto principal. 
          Es importante el uso de \texttt{DAWN\_FETCH\_DEPENDENCIES} para no tener que instalar todas las librerías que usa Dawn ya que estos son pesados y pueden no ser necesarios, y así evitamos gestionar manualmente las dependencias.

    \item \textbf{Organización de los archivos fuente:}\\
          Se recopilan y organizan los archivos fuente del proyecto, excluyendo explícitamente el fichero \texttt{main.cpp} para evitar duplicidad, y se añaden los archivos fuente de ImGui.
          \begin{lstlisting}[language=CMake, caption={Organización de los archivos fuente en CMakeLists.txt}]
            file(GLOB_RECURSE COPPER_SOURCES src/*.cpp src/*.h)
            list(REMOVE_ITEM COPPER_SOURCES ${CMAKE_SOURCE_DIR}/src/main.cpp)\end{lstlisting}

    \item \textbf{Creación del ejecutable:}\\
          Se define el ejecutable principal \texttt{copper}, que se compila a partir de \texttt{main.cpp}, los archivos fuente propios y los de ImGui.
          \begin{lstlisting}[language=CMake, caption={Creación del ejecutable en CMakeLists.txt}]
    add_executable(copper src/main.cpp ${COPPER_SOURCES} ${IMGUI_SOURCES})\end{lstlisting}

    \item \textbf{Definición de directorios de inclusión:}\\
          Se especifican los directorios que contienen los archivos de cabecera para facilitar la compilación.
          \begin{lstlisting}[language=CMake, caption={Definición de directorios de inclusión en CMakeLists.txt}]
    target_include_directories(copper PRIVATE src lib/imgui lib/imgui/misc/cpp lib/imgui/backends ${CMAKE_CURRENT_BINARY_DIR}/src)\end{lstlisting}

    \item \textbf{Vinculación de bibliotecas:}\\
          Se vinculan las bibliotecas necesarias para el funcionamiento del programa, como Dawn/WebGPU, GLM, GLFW y el soporte para WebGPU en GLFW.
          \begin{lstlisting}[language=CMake, caption={Vinculación de bibliotecas en CMakeLists.txt}]
    target_link_libraries(copper PRIVATE dawn::webgpu_dawn glm::glm glfw webgpu_glfw ImGuiFileDialog)\end{lstlisting}

    \item \textbf{Definiciones de compilador:}\\
          Se incluyen definiciones específicas que permiten, por ejemplo, indicar el directorio de recursos y activar la integración de ImGui con WebGPU usando Dawn.
          \begin{lstlisting}[language=CMake, caption={Definiciones de compilador en CMakeLists.txt}]
                target_compile_definitions(copper PRIVATE RESOURCE_DIR="${CMAKE_CURRENT_SOURCE_DIR}/src" IMGUI_IMPL_WEBGPU_BACKEND_DAWN)
\end{lstlisting}
\end{itemize}

\subsection{Proceso de compilación}

Para compilar el proyecto, se debe disponer de CMake y un compilador compatible
con C++20. El proceso estándar usando git para compilar el proyecto consiste en:

\begin{enumerate}
    \item Si fuese necesario añadir los paquetes utilizados por Dawn:
          \begin{lstlisting}[language=bash]
        sudo apt-get install libxrandr-dev libxinerama-dev libxcursor-dev mesa-common-dev libx11-xcb-dev pkg-config nodejs npm\end{lstlisting}
    \item Clonar el repositorio de Git y actualizar los submódulos:
          \begin{lstlisting}[language=bash]
        git clone https://github.com/tu-usuario/copper.git
        cd copper
        git submodule update --init\end{lstlisting}
    \item Compilar en la carpeta build:
    \begin{lstlisting}[language=bash]
        cmake -B build
        cmake --build build -j$(nproc)\end{lstlisting}
    \item Por último si se quiere ejecutar el proyecto:
    \begin{lstlisting}[language=bash]
        ./build/copper\end{lstlisting}
\end{enumerate}

Esto construirá el ejecutable \texttt{copper}, incluyendo todas las
dependencias y archivos fuente indicados en \texttt{CMakeLists.txt}.

\subsection{Función del sistema de construcción}

El sistema CMake facilita:

\begin{itemize}
    \item La gestión automática de dependencias externas.
    \item La configuración multiplataforma.
    \item La compilación eficiente de todos los módulos del programa, asegurando que las
          dependencias y rutas de inclusión están correctamente resueltas.
    \item La integración de recursos y librerías de terceros necesarios para la ejecución
          (por ejemplo, ImGui para la interfaz gráfica, Dawn para el acceso a WebGPU).
\end{itemize}

La configuración descrita en el archivo \texttt{CMakeLists.txt} permite
reproducir el proceso de compilación en distintos sistemas, facilitando el
trabajo colaborativo y la portabilidad del proyecto.