\chapter{Implementación y diseño de los controles}

\section{Introducción}

El sistema de controles en Copper permite la manipulación de la escena 3D y la
interacción directa con los objetos SDF (Signed Distance Fields). Este capítulo
describe en profundidad la arquitectura, matemáticas y tecnologías utilizadas
(especialmente la librería \texttt{glm}), y se divide en tres grandes
apartados: controles de interfaz gráfica (ImGui), controles de gizmo
(GizmoControls) y controles de cámara (CameraController).

\section{Fundamentos matemáticos y uso de \texttt{glm}}

Copper utiliza \textbf{glm} (OpenGL Mathematics) como librería principal para
el manejo de vectores, matrices y cuaterniones, esenciales en la transformación
y manipulación de objetos 3D.

\subsection{Transformaciones en el espacio 3D}

En los archivos \texttt{Camera.cpp}, \texttt{CameraController.cpp} y
\texttt{GizmoControls.cpp}, se emplea \texttt{glm} para:
\begin{itemize}
    \item Representar posiciones y direcciones mediante \texttt{glm::vec3}.
    \item Calcular matrices de vista (\texttt{glm::mat4}), rotaciones con cuaterniones
          (\texttt{glm::quat}), y transformaciones de objetos y cámara.
    \item Realizar operaciones de producto escalar, normalización, traslaciones y
          rotaciones.
\end{itemize}
Por ejemplo, la actualización de la matriz de vista en \texttt{Camera.cpp} se realiza con:
\begin{verbatim}
this->view_matrix = glm::lookAt(this->eye, this->center, this->up);
\end{verbatim}
Esto aplica la transformación de cámara estándar, permitiendo la navegación y
manipulación de la escena.

\subsection{Rotaciones y cuaterniones}

El manejo de rotaciones evita el problema de gimbal lock y permite una
navegación suave. En \texttt{CameraController.cpp}, se construyen cuaterniones
para rotar la cámara y los objetos:
\begin{verbatim}
glm::quat rot_matrix_y = glm::angleAxis(this->vert_angle, glm::vec3(1, 0, 0));
glm::quat rot_matrix_x = glm::angleAxis(this->horiz_angle, glm::vec3(0, 1, 0));
glm::quat q = (rot_matrix_y * rot_matrix_x);
\end{verbatim}
La matriz de vista se actualiza aplicando estas rotaciones, y las
transformaciones se propagan a los controles de gizmo y objetos.

\subsection{Intersecciones y picking}

Para la manipulación mediante gizmos y picking de objetos, se emplean cálculos
geométricos como la intersección de líneas y planos
(\texttt{planeLineIntersection}) y el cálculo de rayos desde la cámara usando
coordenadas UV normalizadas.

\section{Controles de interfaz gráfica: ImGui}

El módulo de interfaz gráfica (\texttt{Interfaz.cpp}, \texttt{Interfaz.h})
utiliza \textbf{ImGui} para implementar menús, sliders y herramientas de
edición.

\subsection{Estructura y funciones principales}

La clase \texttt{Interfaz} interactúa con los módulos \texttt{Coder} y
\texttt{Renderer} para:
\begin{itemize}
    \item Mostrar propiedades de objetos seleccionados (posición, color, tipo, tamaño).
    \item Permitir la edición directa mediante sliders y campos de entrada.
    \item Gestionar la creación, edición y borrado de objetos SDF.
    \item Proporcionar controles globales de la escena (luz, renderizado, operaciones).
    \item Implementar la gestión de archivos para guardar y cargar escenas.
\end{itemize}

\subsection{Ejemplo de interacción}

Al seleccionar un objeto, ImGui presenta sus propiedades y permite
modificarlas:
\begin{verbatim}
ImGui::SliderFloat("X", &selectedObject.x, -10.0f, 10.0f);
ImGui::ColorEdit3("Color", &selectedObject.r);
// Para esferas:
ImGui::SliderFloat("Radius", &selectedObject.size[0], 0.1f, 5.0f);
\end{verbatim}
Cada cambio marca el pipeline como "dirty" para que el renderizador actualice
la escena en tiempo real.

\section{Controles de gizmo: GizmoControls}

El módulo \texttt{GizmoControls} (\texttt{GizmoControls.cpp},
\texttt{GizmoControls.h}) permite la manipulación visual e interactiva de los
objetos SDF seleccionados mediante gizmos (flechas, planos).

\subsection{Arquitectura y flujo de interacción}

\begin{itemize}
    \item \textbf{Inicialización}: Al seleccionar un objeto y pulsar sobre el gizmo, se inicia la manipulación (\texttt{initDrag}).
    \item \textbf{Picking}: Se determina qué parte del gizmo ha sido seleccionada (eje, plano) usando ray marching y cálculos de distancia mínimos.
    \item \textbf{Arrastre y movimiento}: El punto de intersección inicial se calcula con \texttt{gizmoIntersection} y se actualiza en tiempo real mientras el usuario mueve el ratón.
    \item \textbf{Actualización de propiedades}: El centro del objeto se actualiza en \texttt{update}, propagando el nuevo valor al objeto seleccionado en el módulo \texttt{Coder}.
\end{itemize}

\subsection{Matemáticas implicadas}

Se emplean funciones de distancia (SDF) para flechas y planos, y
transformaciones con matrices y cuaterniones para rotar y trasladar los gizmos
respecto al objeto y la cámara. Ejemplo de cálculo de intersección de un rayo
con un plano:
\begin{verbatim}
float d = glm::dot(planeNormal, planePoint - linePoint) / glm::dot(planeNormal, lineDirection);
return linePoint + d * lineDirection;
\end{verbatim}

\subsection{Sincronización con cámara y escena}

El gizmo se actualiza en función de la cámara activa y el aspecto de la
ventana, asegurando coherencia entre la visualización y la interacción.

\section{Controles de cámara: CameraController}

El módulo \texttt{CameraController} (\texttt{CameraController.cpp},
\texttt{CameraController.h}) gestiona la navegación de la cámara en la escena,
aplicando transformaciones mediante eventos de ratón y teclado.

\subsection{Estructura y flujo de eventos}

\begin{itemize}
    \item \textbf{Zoom}: El scroll del ratón modifica el radio de la cámara alrededor del centro, actualizando la vista.
    \item \textbf{Rotación}: El arrastre con el botón izquierdo aplica rotaciones sobre los ángulos vertical y horizontal, usando cuaterniones para evitar gimbal lock.
    \item \textbf{Traslación}: El arrastre con el botón derecho permite mover el centro de la cámara en el plano.
    \item \textbf{Gestión de estados}: El controlador mantiene el estado del ratón y actualiza la cámara solo cuando es necesario, evitando interferencias con la interfaz gráfica.
\end{itemize}

\subsection{Matemáticas y código relevante}

Las transformaciones se basan en las funciones de \texttt{glm} para matrices y
cuaterniones. Ejemplo de rotación acumulada:
\begin{verbatim}
glm::quat rot_matrix_y = glm::angleAxis(this->vert_angle, glm::vec3(1, 0, 0));
glm::quat rot_matrix_x = glm::angleAxis(this->horiz_angle, glm::vec3(0, 1, 0));
glm::quat q = (rot_matrix_y * rot_matrix_x);
this->total_rotation = q;
this->update_view_matrix();
\end{verbatim}
La matriz de vista se recalcula en función de la posición y orientación
deseadas.

\subsection{Integración con el resto del sistema}

El controlador de cámara está sincronizado con la ventana principal y el
renderizador, recibiendo eventos de entrada (mouse, scroll) y actualizando la
matriz de vista que se utiliza en el ciclo de renderizado y en la manipulación
de gizmos.

\section{Picking en el shader}

La técnica de \textbf{picking} en Copper permite identificar el objeto SDF
seleccionado por el usuario, usando un shader especializado que recorre la
escena y devuelve el identificador (\texttt{id}) del objeto más próximo al rayo
lanzado desde el cursor.

El proceso es el siguiente:

\begin{enumerate}
    \item Al pulsar el botón izquierdo del ratón, se genera una pipeline de picking y se
          ejecuta el shader picking.
    \item En el shader, se calcula el rayo a partir de la posición del cursor,
          transformada a coordenadas normalizadas y ajustada por la matriz de vista de
          cámara.
    \item Se realiza ray marching sobre la escena, evaluando la función SDF y almacenando
          el \texttt{id} del objeto más cercano.
    \item El resultado se escribe en un buffer (generalmente una textura de un solo canal
          entero), que se lee desde la CPU para determinar el objeto seleccionado.
\end{enumerate}

El núcleo del shader de picking, generado dinámicamente por la clase
\texttt{Coder}, se parece a este fragmento:

\begin{lstlisting}[language=WGSL, caption={Picking shader fragment}]
@fragment
fn fragmentPickingMain(in: VertexOutput) -> @location(0) i32{
    let cam = transpose(uniforms.mvp_matrix);
    let right = cam[0].xyz;
    let up = cam[1].xyz;
    let forward = cam[2].xyz;
    let eye = cam[0].w * right + cam[1].w * up + cam[2].w * forward;
    let m = uniforms.mouse_position * 2.0 - vec2<f32>(1.0, 1.0);
    let mouse_uv = vec2<f32>(m.x, -m.y / uniforms.aspect_ratio);
    let rd = normalize(mouse_uv.x * right + mouse_uv.y * up + FOV * forward);
    let ro = eye;
    let dc = ray_march_picking(ro, rd);
    return dc.id;
}
\end{lstlisting}

La función \texttt{ray\_march\_picking} recorre la escena utilizando la función
SDF de picking, que para cada objeto evalúa la distancia y el identificador:

\begin{lstlisting}[language=WGSL, caption={Ray marching picking loop}]
fn ray_march_picking(ro: vec3<f32>, rd: vec3<f32>) -> DistanceColor {
    var total_distance: f32 = 0.0;
    for (var i: i32 = 0; i < MAX_MARCHING_STEPS && total_distance < MAX_DISTANCE; i++) {
        let pos = ro + rd * total_distance;
        let dc = sdf_picking(pos);
        if (dc.distance < MIN_DISTANCE) {
            return dc;
        }
        total_distance += dc.distance;
    }
    return DistanceColor(1e6, vec3<f32>(0.0), -1);
}
\end{lstlisting}

La función \texttt{sdf\_picking} está generada dinámicamente y recorre todos
los objetos, devolviendo el identificador del más cercano:

\begin{lstlisting}[language=WGSL, caption={SDF picking para todos los objetos}]
fn sdf_picking(pos: vec3<f32>) -> DistanceColor {
    var result = DistanceColor(1e6, vec3<f32>(0.0, 0.0, 0.0), -1);
    // Para cada objeto:
    // var sphere0: DistanceColor = sdf_sphere(...);
    // ...
    if (sphere0.distance < result.distance) {
        result = sphere0;
    }
    // ...
    return result;
}
\end{lstlisting}

El pipeline de picking escribe el \texttt{id} del objeto seleccionado en la
textura de picking, que luego es leída por la CPU para actualizar el estado de
selección en el sistema.