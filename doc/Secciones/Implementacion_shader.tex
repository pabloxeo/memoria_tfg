\chapter{Implementación de los Shaders}

\section{Introducción}

En este capítulo se describe la implementación de los shaders, explicando cómo
se genera el código, su funcionamiento, y el proceso mediante el cual se
parametriza y escribe el código según la escena y los objetos definidos por el
usuario.

\section{Arquitectura General}

Copper utiliza renderizado basado en shaders escritos en WGSL (WebGPU Shading
Language), generando el código de manera dinámica a partir de la descripción de
la escena. La clase principal responsable de esta tarea es \texttt{Coder}, que
compone el código shader en tiempo de ejecución según los objetos y operaciones
definidos.

\section{Funcionamiento General}

El ciclo de generación y uso de shaders sigue el siguiente flujo:

\begin{enumerate}
    \item El usuario define objetos geométricos (esferas, cajas, conos, cilindros) y
          operaciones booleanas (unión, intersección, sustracción suave, etc.) a través
          de la interfaz gráfica.
    \item Cada vez que la escena cambia, la clase \texttt{Coder} reconstruye el código
          shader combinando funciones SDF (Signed Distance Function) para cada objeto y
          operación.
    \item El código generado incluye la lógica para renderizado normal y picking
          (selección de objetos).
    \item El shader se compila y se utiliza en la pipeline gráfica de WebGPU.
\end{enumerate}

\section{Generación Dinámica del Código Shader}

La clase \texttt{Coder} mantiene una lista de objetos y sus propiedades (tipo,
posición, tamaño, color, operación). Cuando la escena cambia, el método
\texttt{generateShaderCode()} produce el código WGSL correspondiente. El
proceso es el siguiente:

\begin{itemize}
    \item Para cada objeto, se genera una función SDF específica que calcula la distancia
          y el color.
    \item Se combinan las SDFs utilizando las operaciones booleanas indicadas.
    \item Se añade lógica para picking, de modo que cada objeto pueda ser seleccionado
          mediante raycasting.
    \item Si hay objetos auxiliares como gizmos, se añaden funciones SDF para estos
          elementos.
    \item El código generado se concatena junto con una base estándar que define la
          estructura de los shaders, funciones de iluminación, ray marching, etc.
\end{itemize}

El siguiente fragmento ilustra parte del código shader que se puede generar
dinámicamente:

\begin{lstlisting}[language=C++, caption={Fragmento de código WGSL generado}]
fn sdf(pos: vec3<f32>) -> DistanceColor {
    var result = DistanceColor(1e6, vec3<f32>(0.0, 0.0, 0.0), -1);
    var sphere0: DistanceColor = sdf_sphere(pos, uniforms.position, uniforms.size[0], uniforms.color, 0);
    result = opSmoothUnion(result, sphere0, 0.6);
    // ... otros objetos y operaciones
    return result;
}
\end{lstlisting}

\section{Personalización y Parametrización}

La generación del shader se adapta a los parámetros definidos por el usuario:

\begin{itemize}
    \item \textbf{Parámetros geométricos}: posición, tamaño y color de cada objeto se insertan directamente en el código WGSL, en el caso de ser objeto seleccionado se obtienen mediante los \texttt{uniforms}.
    \item \textbf{Operaciones}: el tipo de operación (unión, intersección, sustracción suave) determina qué función de combinación se utiliza.
    \item \textbf{Picking}: se genera una función especial que permite identificar qué objeto ha sido seleccionado por el usuario.
    \item \textbf{Gizmos}: si el usuario selecciona un objeto, se generan SDFs adicionales para los gizmos de manipulación.
\end{itemize}

\section{Funciones SDF y Operaciones Booleanas}

Cada tipo de objeto tiene su propia función SDF:

\begin{itemize}
    \item \texttt{sdf\_sphere}: calcula la distancia de un punto al borde de una esfera.
    \item \texttt{sdf\_box}: calcula la distancia a una caja.
    \item \texttt{sdf\_cone}, \texttt{sdf\_cylinder}: para conos y cilindros.
    \item \texttt{sdf\_plane}: para planos.
\end{itemize}

Las combinaciones entre objetos se realizan con operadores booleanos suaves:

\begin{lstlisting}[language=C++, caption={Operadores booleanos suaves}]
fn opSmoothUnion(d1: DistanceColor, d2: DistanceColor, k: f32) -> DistanceColor { ... }
fn opSmoothIntersect(d1: DistanceColor, d2: DistanceColor, k: f32) -> DistanceColor { ... }
fn opSmoothSubtract(d1: DistanceColor, d2: DistanceColor, k: f32) -> DistanceColor { ... }
\end{lstlisting}

\section{Renderizado y Ray Marching}

El sistema de renderizado se basa en la técnica de \textbf{ray marching}
implementada en el shader principal. Este método permite recorrer la escena
pixel a pixel, determinando la distancia a la superficie más cercana en cada
dirección de visión. El proceso está diseñado para trabajar con funciones de
distancia (SDF, \textit{Signed Distance Function}) que representan primitivas
geométricas y operaciones booleanas entre ellas.

En cada fragmento (píxel), el shader realiza los siguientes pasos:
\begin{itemize}
    \item Se construye el rayo de visión a partir de la posición de la cámara y la
          dirección correspondiente al píxel actual, utilizando los datos del buffer de
          uniformes (\texttt{Uniforms}) y la matriz de vista-proyección
          (\texttt{mvp\_matrix}). La dirección del rayo se normaliza y se ajusta según el
          field-of-view (FOV) y el aspecto de la ventana.
    \item El rayo se avanza iterativamente en la escena, sumando en cada paso la
          distancia mínima a la superficie más cercana, obtenida evaluando la función SDF
          combinada de todos los objetos (\texttt{sdf\_combined}). Este proceso se repite
          hasta que la distancia a la superficie es menor que un umbral mínimo
          (\texttt{MIN\_DISTANCE}) o se alcanza el límite máximo de pasos
          (\texttt{MAX\_MARCHING\_STEPS}) o de distancia (\texttt{MAX\_DISTANCE}), como
          se observa en la función \texttt{ray\_march()} del shader generado en
          \texttt{Coder.cpp}.
    \item Cuando se detecta una intersección con una superficie, se calcula la normal
          local en ese punto mediante diferencias finitas (\texttt{calculate\_normal()}),
          evaluando la variación de la SDF en las tres direcciones espaciales. Esta
          aproximación utiliza pequeñas perturbaciones (\texttt{eps}) y resta los valores
          de la SDF para obtener la derivada parcial en cada eje.
    \item El color final se determina aplicando el modelo de iluminación Blinn-Phong
          sobre el punto de intersección, normal calculada y dirección de visión.
\end{itemize}

\subsection{Cálculo de Normales}

El cálculo de la normal en Copper se realiza en el shader mediante la función
\texttt{calculate\_normal(p)}, donde $p$ es el punto de la superficie detectado
por el ray marching. La normal se calcula como:

\begin{equation}
    \vec{n} = \text{normalize}(
    \begin{bmatrix}
        \text{sdf\_combined}(p+\epsilon_x) - \text{sdf\_combined}(p-\epsilon_x) \\
        \text{sdf\_combined}(p+\epsilon_y) - \text{sdf\_combined}(p-\epsilon_y) \\
        \text{sdf\_combined}(p+\epsilon_z) - \text{sdf\_combined}(p-\epsilon_z)
    \end{bmatrix}
    )
\end{equation}

donde $\epsilon$ es un pequeño desplazamiento en cada eje. De esta forma, se
obtiene la dirección normalizada perpendicular a la superficie. Esta técnica es
estándar en renderizado SDF y permite obtener normales suaves y precisas sin
necesidad de almacenar datos adicionales.

\subsection{Modelo de Iluminación Blinn-Phong}

Copper emplea el modelo de iluminación Blinn-Phong, implementado en la función
\texttt{blinn\_phong\_lighting()} del shader. Este modelo calcula el color
visible en cada punto de la superficie atendiendo a tres componentes:

\begin{itemize}
    \item \textbf{Ambiental}: Representa la luz ambiental global, definida en Copper como una fracción constante de la luz blanca. (\texttt{ambient = 0.2 * light\_color}; donde \texttt{light\_color} es generalmente $(1.0, 1.0, 1.0)$).
    \item \textbf{Difusa}: Calculada según el ángulo entre la normal de la superficie y la dirección de la luz (\texttt{light\_dir}), usando el producto escalar. Cuanto más alineados estén, mayor será la intensidad difusa.
    \item \textbf{Especular}: Usa el vector \texttt{halfway} (media entre la dirección de la luz y la dirección de la vista) para calcular el brillo especular, elevado a una potencia para simular materiales brillantes.
\end{itemize}

El color final en cada punto se calcula como:

\[
    \text{color\_final} = \text{base\_color} \times (\text{ambient} + (1.0 + \text{shadow}) \times (\text{diffuse} + \text{specular}))
\]

donde \texttt{shadow} es el factor de atenuación por sombras, calculado
mediante un nuevo ray marching desde el punto de intersección hacia la luz,
comprobando si existen obstáculos en ese trayecto
(\texttt{calculate\_shadow()}).

\subsection{Cálculo de Sombra}

La sombra en Copper se calcula mediante un segundo proceso de ray marching,
iniciado desde el punto de intersección en la dirección de la luz. En cada
paso, se evalúa la distancia a la superficie más cercana, y se acumula el valor
mínimo relativo a la distancia recorrida, lo que permite obtener sombras suaves
y realistas. Si el rayo encuentra una superficie antes de alcanzar la fuente de
luz, la sombra se intensifica.

Esto es optimizable, ya que se podría añadir el ray marching de las sombras al
proceso de ray marching principal, evitando así la necesidad de un segundo
recorrido por la escena.

\section{Picking en el shader}

La técnica de \textbf{picking} en Copper permite identificar el objeto SDF
seleccionado por el usuario, usando un shader especializado que recorre la
escena y devuelve el identificador (\texttt{id}) del objeto más próximo al rayo
lanzado desde el cursor.

El proceso es el siguiente:

\begin{enumerate}
    \item Al pulsar el botón izquierdo del ratón, se genera una pipeline de picking y se
          ejecuta el shader picking.
    \item En el shader, se calcula el rayo a partir de la posición del cursor,
          transformada a coordenadas normalizadas y ajustada por la matriz de vista de
          cámara.
    \item Se realiza ray marching sobre la escena, evaluando la función SDF y almacenando
          el \texttt{id} del objeto más cercano.
    \item El resultado se escribe en un buffer (una textura de un solo canal entero), que
          se lee desde la CPU para determinar el objeto seleccionado.
\end{enumerate}

El núcleo del shader de picking se encuentra en la función
\texttt{fragmentPickingMain}:

\begin{lstlisting}[language=C++, caption={Picking shader fragment}]
@fragment
fn fragmentPickingMain(in: VertexOutput) -> @location(0) i32{
    let cam = transpose(uniforms.mvp_matrix);
    let right = cam[0].xyz;
    let up = cam[1].xyz;
    let forward = cam[2].xyz;
    let eye = cam[0].w * right + cam[1].w * up + cam[2].w * forward;
    let m = uniforms.mouse_position * 2.0 - vec2<f32>(1.0, 1.0);
    let mouse_uv = vec2<f32>(m.x, -m.y / uniforms.aspect_ratio);
    let rd = normalize(mouse_uv.x * right + mouse_uv.y * up + FOV * forward);
    let ro = eye;
    let dc = ray_march_picking(ro, rd);
    return dc.id;
}
\end{lstlisting}

La función \texttt{ray\_march\_picking} recorre la escena utilizando la función
SDF de picking, que para cada objeto evalúa la distancia y el identificador:

\begin{lstlisting}[language=C++, caption={Ray marching picking loop}]
fn ray_march_picking(ro: vec3<f32>, rd: vec3<f32>) -> DistanceColor {
    var total_distance: f32 = 0.0;
    for (var i: i32 = 0; i < MAX_MARCHING_STEPS && total_distance < MAX_DISTANCE; i++) {
        let pos = ro + rd * total_distance;
        let dc = sdf_picking(pos);
        if (dc.distance < MIN_DISTANCE) {
            return dc;
        }
        total_distance += dc.distance;
    }
    return DistanceColor(1e6, vec3<f32>(0.0), -1);
}
\end{lstlisting}

La función \texttt{sdf\_picking} está generada dinámicamente y recorre todos
los objetos, devolviendo el identificador del más cercano:

\begin{lstlisting}[language=C++, caption={SDF picking para todos los objetos}]
fn sdf_picking(pos: vec3<f32>) -> DistanceColor {
    var result = DistanceColor(1e6, vec3<f32>(0.0, 0.0, 0.0), -1);
    // Para cada objeto:
    // var sphere0: DistanceColor = sdf_sphere(...);
    // ...
    if (sphere0.distance < result.distance) {
        result = sphere0;
    }
    // ...
    return result;
}
\end{lstlisting}

El pipeline de picking escribe el \texttt{id} del objeto seleccionado en la
textura de picking, que luego es leída por la CPU para actualizar el estado de
selección en el sistema.
